diff -up a/src/mediascan.c.orig b/src/mediascan.c
--- a/src/mediascan.c.orig	2011-11-21 14:45:04.000000000 +0100
+++ b/src/mediascan.c	2014-08-08 16:30:00.851518447 +0200
@@ -92,116 +92,6 @@ static const char *VideoExts =
 static const char *ImageExts = ",jpg,png,gif,bmp,jpeg,jpe,";
 static const char *LnkExts = ",lnk,";
 
-#define REGISTER_DECODER(X,x) { \
-          extern AVCodec ff_##x##_decoder; \
-		  avcodec_register(&ff_##x##_decoder); }
-
-#define REGISTER_PARSER(X,x) { \
-          extern AVCodecParser ff_##x##_parser; \
-		  av_register_codec_parser(&ff_##x##_parser); }
-
-///-------------------------------------------------------------------------------------------------
-///  Register codecs to be used with ffmpeg.
-///
-/// @author Andy Grundman
-/// @date 03/15/2011
-///
-/// ### remarks .
-///-------------------------------------------------------------------------------------------------
-
-static void register_codecs(void) {
-  // Video codecs
-  REGISTER_DECODER(H263, h263);
-  REGISTER_DECODER(H264, h264);
-  REGISTER_DECODER(MPEG1VIDEO, mpeg1video);
-  REGISTER_DECODER(MPEG2VIDEO, mpeg2video);
-  REGISTER_DECODER(MPEG4, mpeg4);
-  REGISTER_DECODER(MSMPEG4V1, msmpeg4v1);
-  REGISTER_DECODER(MSMPEG4V2, msmpeg4v2);
-  REGISTER_DECODER(MSMPEG4V3, msmpeg4v3);
-  REGISTER_DECODER(VP6, vp6);
-  REGISTER_DECODER(VP6F, vp6f);
-  REGISTER_DECODER(VP8, vp8);
-  REGISTER_DECODER(WMV1, wmv1);
-  REGISTER_DECODER(WMV2, wmv2);
-  REGISTER_DECODER(WMV3, wmv3);
-  REGISTER_DECODER(MJPEG, mjpeg);
-  REGISTER_DECODER(MJPEGB, mjpegb);
-  REGISTER_DECODER(VC1, vc1);
-  REGISTER_DECODER(FLV, flv);
-
-
-  // Audio codecs, needed to get details of audio tracks in videos
-  REGISTER_DECODER(AAC, aac);
-  REGISTER_DECODER(AC3, ac3);
-  REGISTER_DECODER(DCA, dca);   // DTS
-  REGISTER_DECODER(MP2, mp2);
-  REGISTER_DECODER(MP3, mp3);
-  REGISTER_DECODER(VORBIS, vorbis);
-  REGISTER_DECODER(WMAPRO, wmapro);
-  REGISTER_DECODER(WMAV1, wmav1);
-  REGISTER_DECODER(WMAV2, wmav2);
-  REGISTER_DECODER(WMAVOICE, wmavoice);
-
-  // Not sure which PCM codecs we need
-  REGISTER_DECODER(PCM_DVD, pcm_dvd);
-  REGISTER_DECODER(PCM_S16BE, pcm_s16be);
-  REGISTER_DECODER(PCM_S16LE, pcm_s16le);
-  REGISTER_DECODER(PCM_S24BE, pcm_s24be);
-  REGISTER_DECODER(PCM_S24LE, pcm_s24le);
-
-  // Subtitles
-  REGISTER_DECODER(ASS, ass);
-  REGISTER_DECODER(DVBSUB, dvbsub);
-  REGISTER_DECODER(DVDSUB, dvdsub);
-  REGISTER_DECODER(PGSSUB, pgssub);
-  REGISTER_DECODER(XSUB, xsub);
-
-  // Parsers 
-  REGISTER_PARSER(AAC, aac);
-  REGISTER_PARSER(AC3, ac3);
-  REGISTER_PARSER(DCA, dca);    // DTS
-  REGISTER_PARSER(H263, h263);
-  REGISTER_PARSER(H264, h264);
-  REGISTER_PARSER(MPEG4VIDEO, mpeg4video);
-  REGISTER_PARSER(MPEGAUDIO, mpegaudio);
-  REGISTER_PARSER(MPEGVIDEO, mpegvideo);
-  REGISTER_PARSER(MJPEG, mjpeg);
-  REGISTER_PARSER(VC1, vc1);
-}                               /* register_codecs() */
-
-#define REGISTER_DEMUXER(X,x) { \
-  extern AVInputFormat ff_##x##_demuxer; \
-	av_register_input_format(&ff_##x##_demuxer); }
-#define REGISTER_PROTOCOL(X,x) { \
-  extern URLProtocol ff_##x##_protocol; \
-  av_register_protocol2(&ff_##x##_protocol, sizeof(ff_##x##_protocol)); }
-
-///-------------------------------------------------------------------------------------------------
-///  Registers the formats for FFmpeg.
-///
-/// @author Andy Grundman
-/// @date 03/15/2011
-///
-/// ### remarks .
-///-------------------------------------------------------------------------------------------------
-
-static void register_formats(void) {
-  // demuxers
-  REGISTER_DEMUXER(ASF, asf);
-  REGISTER_DEMUXER(AVI, avi);
-  REGISTER_DEMUXER(FLV, flv);
-  REGISTER_DEMUXER(H264, h264);
-  REGISTER_DEMUXER(MATROSKA, matroska);
-  REGISTER_DEMUXER(MOV, mov);
-  REGISTER_DEMUXER(MPEGPS, mpegps); // VOB files
-  REGISTER_DEMUXER(MPEGTS, mpegts);
-  REGISTER_DEMUXER(MPEGVIDEO, mpegvideo);
-
-  // protocols
-  REGISTER_PROTOCOL(FILE, file);
-}                               /* register_formats() */
-
 ///-------------------------------------------------------------------------------------------------
 ///  Initialises ffmpeg.
 ///
@@ -219,8 +109,7 @@ static void _init(void) {
   if (Initialized)
     return;
 
-  register_codecs();
-  register_formats();
+  av_register_all();
 #ifdef WIN32
   pthread_win32_process_attach_np();
   pthread_win32_thread_attach_np();
diff -up a/src/video.c.orig b/src/video.c
--- a/src/video.c.orig	2011-11-21 00:37:19.000000000 +0100
+++ b/src/video.c	2014-08-08 17:55:54.770691566 +0200
@@ -64,7 +64,7 @@ MediaScanImage *video_create_image_from_
   int no_keyframe_found = 0;
   int skipped_frames = 0;
 
-  if ((avcodec_open(codecs->vc, codec)) < 0) {
+  if ((avcodec_open2(codecs->vc, codec, NULL)) < 0) {
     LOG_ERROR("Couldn't open video codec %s for thumbnail creation\n", codec->name);
     goto err;
   }
--- libmediascan-0.1/src/result.c.orig	2011-11-20 23:37:19.000000000 +0000
+++ libmediascan-0.1/src/result.c	2017-10-29 19:56:59.000000000 +0000
@@ -407,8 +407,8 @@ static int scan_video(MediaScanResult *r
       a->codec = codecs->ac->codec_name;
     }
     // Special case for handling MP1 audio streams which FFMPEG can't identify a codec for
-    else if (codecs->ac->codec_id == CODEC_ID_MP1) {
-      a->codec = CODEC_MP1;
+    else if (codecs->ac->codec_id == AV_CODEC_ID_MP1) {
+      a->codec = AV_CODEC_ID_MP1;
     }
     else {
       a->codec = "Unknown";
--- libmediascan-0.1/src/video.c.orig	2017-10-29 20:01:41.000000000 +0000
+++ libmediascan-0.1/src/video.c	2017-10-29 20:04:53.000000000 +0000
@@ -165,7 +165,7 @@ MediaScanImage *video_create_image_from_
     // use swscale to convert from source format to RGBA in our buffer with no resizing
     // XXX what scaler is fastest here when not actually resizing?
     swsc = sws_getContext(i->width, i->height, codecs->vc->pix_fmt,
-                          i->width, i->height, PIX_FMT_RGB24, SWS_FAST_BILINEAR, NULL, NULL, NULL);
+                          i->width, i->height, AV_PIX_FMT_RGB24, SWS_FAST_BILINEAR, NULL, NULL, NULL);
     if (!swsc) {
       LOG_ERROR("Unable to get swscale context\n");
       goto err;
@@ -179,7 +179,7 @@ MediaScanImage *video_create_image_from_
 
     // XXX There is probably a way to get sws_scale to write directly to i->_pixbuf in our RGBA format
 
-    rgb_bufsize = avpicture_get_size(PIX_FMT_RGB24, i->width, i->height);
+    rgb_bufsize = avpicture_get_size(AV_PIX_FMT_RGB24, i->width, i->height);
     rgb_buffer = av_malloc(rgb_bufsize);
     if (!rgb_buffer) {
       LOG_ERROR("Couldn't allocate an RGB video buffer\n");
@@ -188,7 +188,7 @@ MediaScanImage *video_create_image_from_
     }
     LOG_MEM("new rgb_buffer of size %d @ %p\n", rgb_bufsize, rgb_buffer);
 
-    avpicture_fill((AVPicture *)frame_rgb, rgb_buffer, PIX_FMT_RGB24, i->width, i->height);
+    avpicture_fill((AVPicture *)frame_rgb, rgb_buffer, AV_PIX_FMT_RGB24, i->width, i->height);
 
     // Convert image to RGB24
     sws_scale(swsc, frame->data, frame->linesize, 0, i->height, frame_rgb->data, frame_rgb->linesize);
--- libmediascan-0.1/src/libdlna/audio_aac.c.orig	2017-10-29 20:10:10.000000000 +0000
+++ libmediascan-0.1/src/libdlna/audio_aac.c	2017-10-29 20:11:18.000000000 +0000
@@ -315,7 +315,7 @@ audio_profile_guess_aac_priv (AVCodecCon
     return AUDIO_PROFILE_INVALID;
 
   /* check for AAC variants codec */
-  if (ac->codec_id != CODEC_ID_AAC)
+  if (ac->codec_id != AV_CODEC_ID_AAC)
     return AUDIO_PROFILE_INVALID;
   
   switch (type)
--- libmediascan-0.1/src/libdlna/audio_ac3.c.orig	2017-10-29 20:13:51.000000000 +0000
+++ libmediascan-0.1/src/libdlna/audio_ac3.c	2017-10-29 20:14:39.000000000 +0000
@@ -39,7 +39,7 @@ audio_profile_guess_ac3 (AVCodecContext 
     return AUDIO_PROFILE_INVALID;
 
   /* check for AC3 codec */
-  if (ac->codec_id != CODEC_ID_AC3)
+  if (ac->codec_id != AV_CODEC_ID_AC3)
     return AUDIO_PROFILE_INVALID;
   
   /* supported channels: 1/0, 2/0, 3/0, 2/1, 3/1, 2/2, 3/2 */
--- libmediascan-0.1/src/libdlna/audio_amr.c.orig	2017-10-29 20:19:33.000000000 +0000
+++ libmediascan-0.1/src/libdlna/audio_amr.c	2017-10-29 20:20:15.000000000 +0000
@@ -53,7 +53,7 @@ audio_is_valid_amr (AVCodecContext *ac)
   if (!ac)
     return 0;
 
-  if (ac->codec_id != CODEC_ID_AMR_NB)
+  if (ac->codec_id != AV_CODEC_ID_AMR_NB)
     return 0;
   
   /* only mono is supported */
@@ -89,7 +89,7 @@ audio_is_valid_amr_wb (AVCodecContext *a
   if (!ac)
     return 0;
 
-  if (ac->codec_id != CODEC_ID_AMR_WB)
+  if (ac->codec_id != AV_CODEC_ID_AMR_WB)
     return 0;
   
   /* valid sampling rates: 8, 16, 24, 32 and 48 kHz */
--- libmediascan-0.1/src/libdlna/audio_atrac3.c.orig	2011-04-27 00:44:30.000000000 +0000
+++ libmediascan-0.1/src/libdlna/audio_atrac3.c	2017-10-29 20:21:13.000000000 +0000
@@ -39,7 +39,7 @@ audio_profile_guess_atrac (AVCodecContex
     return AUDIO_PROFILE_INVALID;
 
 #if LIBAVCODEC_VERSION_INT >= ((51<<16)+(40<<8)+4)
-  if (ac->codec_id == CODEC_ID_ATRAC3)
+  if (ac->codec_id == AV_CODEC_ID_ATRAC3)
     return AUDIO_PROFILE_ATRAC;
 #endif
 
--- libmediascan-0.1/src/libdlna/audio_g726.c.orig	2011-04-27 00:44:30.000000000 +0000
+++ libmediascan-0.1/src/libdlna/audio_g726.c	2017-10-29 20:22:03.000000000 +0000
@@ -31,7 +31,7 @@ audio_profile_guess_g726 (AVCodecContext
   if (!ac)
     return AUDIO_PROFILE_INVALID;
 
-  if (ac->codec_id != CODEC_ID_ADPCM_G726)
+  if (ac->codec_id != AV_CODEC_ID_ADPCM_G726)
     return AUDIO_PROFILE_INVALID;
   
   if (ac->channels != 1)
--- libmediascan-0.1/src/libdlna/audio_lpcm.c.orig	2011-04-27 00:44:30.000000000 +0000
+++ libmediascan-0.1/src/libdlna/audio_lpcm.c	2017-10-29 20:22:51.000000000 +0000
@@ -50,8 +50,8 @@ audio_profile_guess_lpcm (AVCodecContext
     return AUDIO_PROFILE_INVALID;
 
   /* check for 16-bit signed network-endian PCM codec  */
-  if (ac->codec_id != CODEC_ID_PCM_S16BE &&
-      ac->codec_id != CODEC_ID_PCM_S16LE)
+  if (ac->codec_id != AV_CODEC_ID_PCM_S16BE &&
+      ac->codec_id != AV_CODEC_ID_PCM_S16LE)
     return AUDIO_PROFILE_INVALID;
 
   /* supported channels: mono or stereo */
--- libmediascan-0.1/src/libdlna/audio_mp1.c.orig	2011-04-27 00:44:30.000000000 +0000
+++ libmediascan-0.1/src/libdlna/audio_mp1.c	2017-10-29 20:24:15.000000000 +0000
@@ -31,7 +31,7 @@ audio_profile_guess_mp1 (AVCodecContext 
   if (!ac)
     return AUDIO_PROFILE_INVALID;
 
-  if (ac->codec_id != CODEC_ID_MP1)
+  if (ac->codec_id != AV_CODEC_ID_MP1)
     return AUDIO_PROFILE_INVALID;
   
   if (ac->channels > 5)
--- libmediascan-0.1/src/libdlna/audio_mp2.c.orig	2011-04-27 00:44:30.000000000 +0000
+++ libmediascan-0.1/src/libdlna/audio_mp2.c	2017-10-29 20:24:24.000000000 +0000
@@ -31,7 +31,7 @@ audio_profile_guess_mp2 (AVCodecContext 
   if (!ac)
     return AUDIO_PROFILE_INVALID;
 
-  if (ac->codec_id != CODEC_ID_MP2)
+  if (ac->codec_id != AV_CODEC_ID_MP2)
     return AUDIO_PROFILE_INVALID;
   
   if (ac->channels > 5)
--- libmediascan-0.1/src/libdlna/audio_mp3.c.orig	2011-04-27 00:44:30.000000000 +0000
+++ libmediascan-0.1/src/libdlna/audio_mp3.c	2017-10-29 20:24:33.000000000 +0000
@@ -47,7 +47,7 @@ audio_is_valid_mp3_common (AVCodecContex
     return 0;
 
   /* check for MP3 codec */
-  if (ac->codec_id != CODEC_ID_MP3)
+  if (ac->codec_id != AV_CODEC_ID_MP3)
     return 0;
   
   /* only mono and stereo are supported */
--- libmediascan-0.1/src/libdlna/audio_wma.c.orig	2011-04-27 00:44:30.000000000 +0000
+++ libmediascan-0.1/src/libdlna/audio_wma.c	2017-10-29 20:24:51.000000000 +0000
@@ -55,7 +55,7 @@ audio_profile_guess_wma (AVCodecContext 
     return ap;
 
   /* check for WMA codec */
-  if (ac->codec_id != CODEC_ID_WMAV1 && ac->codec_id != CODEC_ID_WMAV2)
+  if (ac->codec_id != AV_CODEC_ID_WMAV1 && ac->codec_id != AV_CODEC_ID_WMAV2)
     return ap;
 
   if (ac->sample_rate <= 48000)
--- libmediascan-0.1/src/libdlna/av_mpeg1.c.orig	2011-04-27 00:44:30.000000000 +0000
+++ libmediascan-0.1/src/libdlna/av_mpeg1.c	2017-10-29 20:26:07.000000000 +0000
@@ -42,7 +42,7 @@ probe_mpeg1 (AVFormatContext *ctx dlna_u
     return NULL;
   
   /* check for MPEG-1 video codec */
-  if (codecs->vc->codec_id != CODEC_ID_MPEG1VIDEO)
+  if (codecs->vc->codec_id != AV_CODEC_ID_MPEG1VIDEO)
     return NULL;
 
   /* video bitrate must be CBR at 1,151,929.1 bps */
@@ -72,7 +72,7 @@ probe_mpeg1 (AVFormatContext *ctx dlna_u
     return NULL;
 
   /* check for MPEG-1 Layer-2 audio codec */
-  if (codecs->ac->codec_id != CODEC_ID_MP2)
+  if (codecs->ac->codec_id != AV_CODEC_ID_MP2)
     return NULL;
   
   /* supported channels: stereo only */
--- libmediascan-0.1/src/libdlna/av_mpeg2.c.orig	2011-04-27 00:44:30.000000000 +0000
+++ libmediascan-0.1/src/libdlna/av_mpeg2.c	2017-10-29 20:26:13.000000000 +0000
@@ -465,7 +465,7 @@ probe_mpeg_ts (AVFormatContext *ctx,
   int i;
   
   /* check for MPEG-2 MP@LL profile */
-  if (codecs->ac->codec_id == CODEC_ID_AAC)
+  if (codecs->ac->codec_id == AV_CODEC_ID_AAC)
   {
     /* 352x288 only */
     if (codecs->vc->width != 352 && codecs->vc->height != 288)
@@ -554,7 +554,7 @@ probe_mpeg_ts (AVFormatContext *ctx,
   if (codecs->vc->bit_rate + codecs->ac->bit_rate > 19392700)
     return NULL; 
 
-  if (codecs->ac->codec_id != CODEC_ID_AC3)
+  if (codecs->ac->codec_id != AV_CODEC_ID_AC3)
     return NULL;
 
   /* 48 KHz only */
@@ -634,7 +634,7 @@ probe_mpeg2 (AVFormatContext *ctx,
     return NULL;
   
   /* check for MPEG-2 video codec */
-  if (codecs->vc->codec_id != CODEC_ID_MPEG2VIDEO)
+  if (codecs->vc->codec_id != AV_CODEC_ID_MPEG2VIDEO)
     return NULL;
 
   switch (st)
--- libmediascan-0.1/src/libdlna/av_mpeg4_part10.c.orig	2011-04-27 00:44:30.000000000 +0000
+++ libmediascan-0.1/src/libdlna/av_mpeg4_part10.c	2017-10-29 20:26:53.000000000 +0000
@@ -1230,7 +1230,7 @@ probe_avc (AVFormatContext *ctx,
     return NULL;
 
   /* check for H.264/AVC codec */
-  if (codecs->vc->codec_id != CODEC_ID_H264)
+  if (codecs->vc->codec_id != AV_CODEC_ID_H264)
     return NULL;
 
   /* check for a supported container */
--- libmediascan-0.1/src/libdlna/av_mpeg4_part2.c.orig	2011-04-27 00:44:30.000000000 +0000
+++ libmediascan-0.1/src/libdlna/av_mpeg4_part2.c	2017-10-29 20:27:11.000000000 +0000
@@ -50,13 +50,13 @@ static const struct {
   int codec_id;
   mpeg4_vcodec_type_t type;
 } avf_vcodec_mapping[] = {
-  { CODEC_ID_H263,                      MPEG4_VCODEC_H263 },
-  { CODEC_ID_H263I,                     MPEG4_VCODEC_H263 },
-  { CODEC_ID_H263P,                     MPEG4_VCODEC_H263 },
-  { CODEC_ID_MPEG4,                     MPEG4_VCODEC_P2 },
-  { CODEC_ID_MSMPEG4V1,                 MPEG4_VCODEC_P2 },
-  { CODEC_ID_MSMPEG4V2,                 MPEG4_VCODEC_P2 },
-  { CODEC_ID_MSMPEG4V3,                 MPEG4_VCODEC_P2 },
+  { AV_CODEC_ID_H263,                      MPEG4_VCODEC_H263 },
+  { AV_CODEC_ID_H263I,                     MPEG4_VCODEC_H263 },
+  { AV_CODEC_ID_H263P,                     MPEG4_VCODEC_H263 },
+  { AV_CODEC_ID_MPEG4,                     MPEG4_VCODEC_P2 },
+  { AV_CODEC_ID_MSMPEG4V1,                 MPEG4_VCODEC_P2 },
+  { AV_CODEC_ID_MSMPEG4V2,                 MPEG4_VCODEC_P2 },
+  { AV_CODEC_ID_MSMPEG4V3,                 MPEG4_VCODEC_P2 },
   { -1, 0 }
 };
    
--- libmediascan-0.1/src/libdlna/av_wmv9.c.orig	2011-04-27 00:44:30.000000000 +0000
+++ libmediascan-0.1/src/libdlna/av_wmv9.c	2017-10-29 20:28:48.000000000 +0000
@@ -245,7 +245,7 @@ probe_wmv9 (AVFormatContext *ctx dlna_un
     return NULL;
 
   /* check for WMV3 (Simple and Main profiles) video codec */
-  if (codecs->vc->codec_id != CODEC_ID_WMV3)
+  if (codecs->vc->codec_id != AV_CODEC_ID_WMV3)
     return NULL;
 
   /* get video profile */
